#!/usr/bin/perl

# This programs listens for UDP packets on port 17896.
# It collects and sorts output data from SpiNNaker
# an dumps it to standard out.

use strict;
use warnings;

use IO::Socket::INET;

my $version = '0.99';

my $port = 17896;
my $socket;
my $socket_fd;

my $HOST_FINAL = 0;
my $HOST_NORMAL = 1;
my $HOST_INFO = 2;

my $HOST_NaN = -1;

my @num_outs;
my $num_grps  = 0;
my $num_ticks = 0;
my $info_ctr = 0;

my $cur = 0;
my $nxt = 1;

my @epoch = (0xffffffff, 0xffffffff);
my @example = (0xffffffff, 0xffffffff);
my @event = (0xffffffff, 0xffffffff);
my @tick = (0xffffffff, 0xffffffff);

my $ltick = 0xffffffff;

my @bindex = (0, 0);
my @grp_ctr = (0, 0);

my $bstart = [[], []];
my $outputs = [[], []];
my $targets = [[], []];


sub usage
{
    warn "usage: output_mon <args>\n";
    warn "  -port <num>         - set UDP port number (default $port)\n";
    die  "  -version            - print version number\n";
}


sub process_args
{
    while ($#ARGV >= 0)
    {
	my $arg = shift @ARGV;

	if ($arg eq '-version')
	{
	    die "output_mon - v$version\n";
	}
	elsif ($arg eq '-port')
	{
	    die "port not specified\n" unless defined $ARGV[0] &&
		$ARGV[0] =~ /^\d+$/;
	    $port = shift @ARGV;
	}
	else
	{
	    usage ();
	}
    }
}


sub open_input
{
    $socket = new IO::Socket::INET (LocalPort => $port,
				    Proto => 'udp',
				    Blocking => 0);

    die "failed to create socket: $!\n" unless $socket;

    $socket_fd = fileno ($socket);

    warn "listening on port $port ...\n";
}


sub print_outputs
{
    if ($tick[$cur] == 0)
    {
	printf "%d %d\n", $epoch[$cur], $example[$cur];
	printf "%d %d\n", $num_ticks, $num_grps;
    }

    printf "%d %d\n", $tick[$cur], $event[$cur];

    for (my $i = 0; $i < $num_grps; $i++)
    {
	printf "%d 1\n", $num_outs[$i];

	my $low = $bstart->[$cur][$i];
	my $high = $low + $num_outs[$i];
	for (my $j = $low; $j < $high; $j++)
	{
	    printf "%f ", ((1.0 * $outputs->[$cur][$j]) / (1.0 * (1 << 15)));
	    my $tg = ((1.0 * $targets->[$cur][$j]) / (1.0 * (1 << 15)));
            if ($tg == $HOST_NaN)
            {
		printf "-\n";
	    }
            else
            {
		printf "%d\n", ($tg > 0.5) ? 1 : 0;
	    }
	}
    }
}


sub main_loop
{
    my $run = 1;

    while ($run != 0)
    {
	my $rm = '';
	vec ($rm, $socket_fd, 1) = 1;
	
	my $n = select ($rm, undef, undef, 0.1);
	next if $n == 0;
	
	my $addr = recv ($socket, my $buf, 65536, 0);
	
	unless (defined $addr)
	{
	    warn "!! recv failed\n";
	    next;
	}
	
	my ($pad, $flags, $tag, $dp, $sp, $da, $sa, $cr, $sq, $a1, $a2, $a3, $d) = 
	    unpack 'v C4 v2 v2 V3 a*', $buf;
	
	my $cmd = $cr;
	my $grp = $sq;

	my @t = unpack 's*', $d;

#printf "c:%d g:%d t:%d s:%d\n", $cmd, $grp, $a3, scalar(@t);

	if ($cmd == $HOST_INFO)
	{
	    $num_outs[$sq] = $a1;
	    $num_grps = $a2;
	    $num_ticks = $a3;

	    $info_ctr++;
	    if ($info_ctr == $num_grps)
	    {
		$info_ctr = 0;
	    }

	}
	else
	{
	    my $inx = $cur;
	    if ($tick[$cur] == 0xffffffff)
	    {
		if (($a3 != 0) && ($a3 != ($ltick + 1)))
		{
		    printf "missing tick e:%d r:%d\n", ($ltick + 1), $a3;
		}

		$epoch[$cur]   = $a1;
		$example[$cur] = ($a2 & 0x0000ffff);
		$event[$cur]   = ($a2 >> 16);
		if ($event[$cur] > 32767) { $event[$cur] = -1; }
		$tick[$cur]    = $a3;
	    }
	    elsif ($tick[$cur] != $a3)
	    {
		if (($a3 != 0) && ($a3 != ($tick[$cur] + 1)))
		{
		    printf "missing tick e:%d r:%d\n", $tick[$cur] + 1, $a3;
		}

		$inx = $nxt;
		if ($tick[$nxt] == 0xffffffff)
		{
		    $epoch[$nxt]   = $a1;
		    $example[$nxt] = ($a2 & 0x0000ffff);
		    $event[$nxt]   = ($a2 >> 16);
		    if ($event[$nxt] > 32767) { $event[$nxt] = -1; }
		    $tick[$nxt]    = $a3;
		}
		elsif ($tick[$nxt] != $a3)
		{
		    printf "wrong tick e:%d r:%d\n", $tick[$nxt], $a3;
		}
	    }

	    my $bi = $bindex[$inx];

	    $bstart->[$inx][$grp] = $bi;

	    for (my $i = 0; $i < @t/2; $i++)
	    {
		$outputs->[$inx][$bi] = $t[2 * $i];
		$targets->[$inx][$bi] = $t[(2 * $i) + 1];
		$bi++;
	    }

	    $bindex[$inx] = $bi;
	    $grp_ctr[$inx]++;

#printf "ix:%d gc:%d bi:%d\n", $inx, $grp_ctr[$inx], $bindex[$inx];

	    if ($grp_ctr[$inx] == $num_grps)
	    {
		print_outputs ();

		$grp_ctr[$inx] = 0;
		$ltick = $tick[$inx];
		$tick[$inx] = 0xffffffff;
		$nxt = $cur;
		$cur = 1 - $cur;
		if ($cmd == $HOST_FINAL)
		{
		    $run = 0;
		}
	    }
	}
    }
}


process_args ();

open_input ();

main_loop ();
